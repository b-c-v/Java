package com.bcv.BoostBrain.lesson_12;

/*
1. Коллекция - это структурированные хранилища однотипных объектов.
2. Структура хранения данных в разных коллекциях завист от предназначения коллекции
3. Коллекции не могут использваться для примитивных типов
4. У примитивных типов есть обертки, например Integer, Double и т.д.
5. Наиболее часто используются коллекции следующих типов - список (List), множество или набор (Set) и ассоциативный массив или карта (Map)

1. Список - это простейший контейнер, который позволяет хранить произвольный набор объектов.
2. Добаление элемента в конец списка производится методом add(...), чтение с помощью метода get(int index), ...), a index имеет тот же смысл, что индекс в массиве, то есть порядковый номер элемента
3. Список имеет смысл использовать вместо массива в том случае, если заранее не известно количество элементов, елси требуются частые вставки  середину.
4. Два основынх типа список - это ArrayList и LinkedList

1. Множества - это хранилище, которое хранит только уникальные значения, в множестве невозожно хранить несколько одинкаовых элементов.
2. Добавить элемент в множество можно методом add(Oject o), удалить методом remove(Object object), проверить есть ли объект в множестве можно методом contains(Object o).
3. Множества могут быть сортированными - TreeSet и несортированными - HashSet.
4. Самые полезные операции над множествами - это объединение множеств - addAll(...), пересечение множеств - retainAll(...) и разность множеств - removeAll(...)

1. Карты или ассоциативный массив - это хранилище объектов, в которо вместо порядкового номера можно использовать другие объекты.
2. Объект, который используется вместо порядкового номера, называется ключ
3. Получить сохраненный объект по ключу можно методом get(Object key), положить объект можно с помощью метода put(Object key, Object o), для удаления используется метод remove(Object key), a для проверки наличия какого-то объекта - метод contains(Object key).
4. Самые используемые карты это HashMap и TreeMap

1. Для списков, множеств и массивов вместо стандартного цикла for можно использовать цикл особой формы
2. Его синтаксис отличается от стандартного:

  for(Тип_элемента имя_переменной: массив_элементов){
      Операция над "имя_переменной" }
      
3. Такая форма цикла повзоляет перебрать все элементы массива, списка или множества.
*/

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.TreeMap;

public class Collections {

    public static void main(String[] args) throws IOException {

        // загружаем данные из файла в память
        FileInputStream stream = new FileInputStream(
                "d:/program/eclipse/eclipse-workspace/BoostBrain/src/lesson_12/moscow-buildings.csv"); // при написании пути к файлу используем / а не так как принято в виндовс
        int length = stream.available();// узнаем длину файла с помощью команды available
        byte[] data = new byte[length]; // создаем байтовый массив и указываем длину length
        stream.read(data);// читаем массив

        String text = new String(data);// преобразовываем байтовые данные в текст. Создаем новый объект String командой new и в конструкторе указываем данные data которые скачали из файла

        // System.out.println(text); // выводим на экран текстовые данные которые получили

        // 2 создаем контейнер т.е. список который содержит в себе массив с именем LineWords
        ArrayList<String[]> lineWords = new ArrayList<>();

        String[] lines = text.split("\n"); // текст разбиваем на строки с помощью команды split (в качестве разделителя указываем новую строку \n) которая возращает массив строк
        // выводим текст с помощью цикла
        for (String line : lines) {

            // System.out.println(line); // добавляем метку, чтобы было видно наглядно что выводим построчно
            // System.out.println("-----------------");


            String[] words = line.split(",");// делим строки на отдельные слова. Полученную строку командой split разбиваем и указываем , в качестве разделителя. Split возвращаем массив слов

            lineWords.add(words); // 2 сохраняем массив отдельных слов в наш список командой add
        }

        /*
         * // 2 выведем отдельные слова с помощью цикла for (String[] words : lineWords)
         * { // 2 делаем вложенный цикл, который перебирает отдельные слова. for (String
         * word : words) { //2 выводим на экран слова отделяя их | и отделяя строки ----
         * System.out.print(word); System.out.print("|"); } System.out.println("----");
         * }
         */

        /*
         * //3 выводим строки в которых год 1999 (это 10 столбец или 9 место в массиве)
         * for (String[] words : lineWords) { if (words[9].equals("1999")) { for (String
         * word : words){ System.out.print(word); System.out.print("|"); }
         * System.out.println("----");
         */

	/*// 4 создаем асоциативный массив. Считаем количество домов построенных в 1999 году.
	HashMap<String, Integer> map = new HashMap<String, Integer>();*/

        // 5 создаем структурированный массив, который считает количество домов построенных в каждом году
        TreeMap<String, Integer> map = new TreeMap<String, Integer>();

        //общий код для 4 и 5 пунктов
        for (String[] words : lineWords) {
            // если в карте присутствует значение, которое есть в words[9] т.е. в 10 столбце
            if (map.containsKey(words[9])) {
                Integer k = map.get(words[9]);
                // количество домов, если уже существует увеличивается на 1
                k = k + 1;
                // кладем значение k обратно
                map.put(words[9], k);
                // если такого значения в карте небыло кладем туда 1
            } else {
                map.put(words[9], 1);
            }

            System.out.println(map.get("1999"));

            // 5 смотрим количество домов построенных в каждом отдельном году. В карте есть метод keySet который возвращает все ключи т.е. содержит в себе множество всех ключей.
            for (String key : map.keySet()) {
                System.out.println("Year: " + key + " Count:" + map.get(key));
            }
        }

    }
}
